/**
 * Справочник по функциям в scala.
 * Для начала стоит вообще разделить, что функция, а что - нет и в чём там разница.
 * Первое, что надо понять - это то, что любой код у нас лежит в объектах и просто так валяться ничего нигде не может.
 * И даже repl эмулирует интерпретатор, а на деле через оборачивает код в объект и через reflection создаёт переменные.
 * Ну да не о том речь.
 * То, что выдаёт себя за функцию может на деле иметь разную природу.
 * Вот, допустим есть у нас объект и его метод:
 */
object obj0{
  def intPlusOne(x:Int):Int = x+1
}

/**
 * При попытке написать что-то типа
 * obj0.intPlusOne
 * без указания параметров код упадёт, потому что метод как таковой не является значением,
 * то есть его нельзя присвоить переменной или передать в функцию.
 * Что-же, перепишем наш объект:
 */
object obj1{
  def intPlusOne:Int=>Int = x=>x+1
}

/**
 * Вообще кажется, что ничего не изменилось, но вот теперь такой код не падает.
 */
obj1.intPlusOne

/**
 * Казалось бы, судя по ключевому слову при объявлении obj1.intPlusOne - это всё ещё метод, так почему там не работает,
 * а здесь - вполне?
 * Но, рассмотрим сигнатуру внимательнее:
 * def intPlusOne:Int=>Int = x=>x+1
 * Действительно, это метод. Однако метод, не принимающий параметров, и возвращающий значение типа Int=>Int
 * Тип этого значения - функция, принимающая Int и возвращающая Int. А раз это значение, то можно переписать объект так:
 */
object obj2{
  val intPlusOne:Int=>Int = x=>x+1
}
obj2.intPlusOne
/**
 * Как видим, всё работает и тип значения сохранился, а разница лишь в том, что в первом случае мы каждый раз вычисляем
 * значение(то есть функцию) заново, а во втором значение вычисляется 1 раз. Соответственно,
 * если для формирования функции нам не нужны параметры, то лучше использовать val, хоть с точки зрения функциональности
 * - разницы не будет.
 * Тем не менее, чуть изменим описание объектов:
 */

object obj3{
  var n = 0
  def intPlusN:Int=>Int = x=>x+n
}
object obj4{
  var n = 0
  val intPlusN:Int=>Int = x=>x+n
}

/**
 * А теперь вопрос на логику внутренней работы JVM: Будет ли меняться значение intPlusN в каждом из случаев?
 *
 * Для obj3 ответ очевиден. Да, будет, ведь мы каждый раз пересчитываем значение (тело функции) заново.
 * Менее очевидно то, почему это также будет верно для obj4. Ведь тело функции явно будет вычислено однажды.
 * А вот тут в силу вступает то, что значение в jvm передаётся только по ссылке, а разрешается только непосредственно в
 * момент вычислений. В итоге:
 */
obj3.intPlusN(1)
obj4.intPlusN(1)

obj3.n = 2
obj4.n = 2

obj3.intPlusN(1)
obj4.intPlusN(1)

/**
 * Как видно, так оно и произошло.
 * Но вопрос, почему не сконструировать язык так, чтобы всё было функцией?
 * Ответ заключается в идеологии scala. В ней принято, что всякое значение является объектом.
 * Следовательно, и функция должна быть объектом тоже. Однако, раз функция - это объект,
 * применение функции - логично сделать её методом. И следовательно, метод не должен быть объектом, так как иначе мы
 * получим бесконечную внутреннюю вложенность объектов.
 *
 * И вот теперь мы подошли и объекту функции, который стоит чуть более подробного рассмотрения.
 */

val f0:Int=>Double = x=> x+1

/**
 * Во - первых у него есть метод apply, аргументы и тело которого собственно и олицетворяют нашу функцию.
 */
f0(10)

/**
 * Есть методы andThen и compose, формирующие новую функцию путём связывания имеющейся функции с другой функцией.
 * Разница лишь в том, что andThen добавляет функцию справа, а compose - слева
 * На этом с особенными методами - всё.
 */

val f1:Double=>String = x=> x.toString
val f2:Char=>Int = x=> x.toInt

val lComposition = f0.compose(f2)
val rComposition = f0.andThen(f1)

/**
 * Теперь вернёмся к самому началу и заново запишем первый объект
 */
object obj5{
  def intPlusOne(x:Int):Int = x+1
}

/**
 * Действительно, если написать так, то код упадёт:
 * val f3 = obj5.intPlusOne
 * Но часто необходимо вытащить метод из объекта и сделать его функцией. Способ сделать это есть:
 */
 
val f3 = obj5.intPlusOne(_)

/**
 * Здесь идея ругается, но такая запись наиболее понятна.
 *
 * Очевидно, но слишком важно, чтобы не сказать:
 * У метода своих методов, естественно нет и потому
 * obj5.obj5.intPlusOne.andThen(...) - тоже упадёт с ошибкой
 *
 * И последнее, о чём стоит проговорить в контексте функций - это каррирование.
 * Для начала запишем, функцию в полностью каррированном виде:
 */
val f4:Int=>Int=>Int=>Int = a=>b=>c=>a+b+c

/**
 * Вообще сначала запись кажется довольно странной. И тип какой-то неясный и запись функции, в общем - тоже.
 * Для понимания того, что здесь происходит нужно рассказать, что же такое каррирование.
 * Кррирование - это метод, позволяющий преобразовать функцию 2 аргументов в функцию одного аргумента, возвращающую
 * функцию одного аргумента.
 * То есть, на самом деле перед нами не функция 3 аргументов, а последовательно уложенные друг в друга функции
 * одного аргумента.
 *
 * Теперь о том, зачем это нужно в программировании.
 * Во-первых, это позволяет использовать что-то наподобие паттерна "билдер", собирая итоговую функцию "по-кусочкам"
 * Во-вторых, это возможность логически разделить аргументы.
 * В-третьих, это даёт некоторую гибкость, ведь можно передавать отдельные Int, а можно расставить скобки по-другому и
 * передавать уже, например Int => (Int=>Int) => Int.
 * Или получать: Int => Int => (Int=>Int)
 * Или вообще:   (Int=>Int) => (Int=>Int)
 *
 * Ещё на практике бывает так, что метод надо таки передать как аргумент и зачастую scala
 * сама сделает неявное преобразование:
 */
object obj6{
  def intPlusOne(x:Int):Int = x+1
}

(1 to 10).map(obj6.intPlusOne)

//todo: ещё одни метод задания каррированых функций.

object obj7{
  val f:(Int=>Int)=>Int = f0=> f0(10)
}
obj7.f(_+2)
